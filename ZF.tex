\chapter{Automatisierung}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition Automatisierung]
\textnormal{Unter Automatisierung (DIN19222) versteht man das gezielte Ausrüsten einer Einrichtung, so dass sie ganz oder teilweise ohne Mitwirkung des Menschen geschieht und arbeiten kann.}
\end{tcolorbox}

\textnormal{Die Automatisierungspyramide ist der Versuch die gesamte Automatisierungskette auf ein Bild abzubilden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.8\columnwidth]{img/Bild_2025-09-23_094245630.png}
\end{figure}
\textnormal{Die Darstellung ist wie folgt zu interpretieren: Je weiter unten, desto schneller müssen die Komponenten reagieren und je weiter oben, ist die Datenmenge grösser. Die Absicht der Automatisierung ist, dass die automatisierte Anlage bis ins ERP der Firma eingepflegt wird. So muss z.B. keine spezielle Benutzeroberfläche geladen werden um ein neuer Prozess auf der Anlage zu starten.}

\section{Steuerung - Überblick}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.4\columnwidth]{img/Bild_2025-09-23_093009913.png}
\end{figure}
\textnormal{Die Bedienung ist wo das GUI (Graphical User Interface) dargestellt wird. Hier werden vom Benutzer Eingaben getätigt, wie z.B. Job oder Rezeptwahl.}\\
\textnormal{Der Controller innerhalb der Steuerung/Anlage ist die CPU/SPS. Eine Automatisierung ist häufig eine (PID-)Regelungsaufgabe. Die SPS ist mit Aktoren und Sensoren verbunden:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item Sensoren liefern Informationen
    \item Aktoren lösen Aktion aus
\end{itemize}
\textnormal{Die Schnittstellen der Sensoren/Aktoren ist entweder eine Spannung oder einen Strom. Die Spannung ist jedoch eher weniger gängig im Moment, da die Spannung anfälliger auf Störeinflüsse ist als ein Strom. Die gängigsten Schnittstellen sind. Ein weiterer Vorteil der Stromschnittstelle ist, dass auch ein Kabelbruch detektiert werden kann, da der Strom nie 0 wird:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item $0V-10V$
    \item $4mA - 20mA$
\end{itemize}
\newcolumn

\subsection{Klemmen}
\textnormal{Die Klemmen stellen die Ein- und Ausgänge einer SPS dar und können auf der Feldebene der SPS über ein Bussystem erweitert werden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_093955196.png}
\end{figure}
\textnormal{Klemmen können über RS485 abgesetzt werden und an einem anderen Ort als direkt bei der SPS eingesetzt werden.}

\section{Allgemeine Aufgaben}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_094648272.png}
\end{figure}

\section{Allgemeine Anforderungen}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_094725052.png}
\end{figure}
\newcolumn

\chapter{SPS}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.3\columnwidth]{img/Bild_2025-09-23_095018637.png}
\end{figure}
\textnormal{Eine SPS ist eine 'Speicherprogrammierbare Steuerung'. Auf Englisch wird sie PLC (Programmable Logic Controller) genannt. Sehr wichtig: die SPS arbeitet konventionell möglichst auf if/else Statements und verarbeitet sämtlicher Code in jedem Zyklus einmal. Das Arbeitsprinzip ist:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bild_2025-09-23_095127951.png}
\end{figure}

\section{Feldbus}
\textnormal{Der Feldbus ist die Kommunikationsschnittstelle der SPS zu den Klemmen und entsprechend Ein- und Ausgängen. Es hängen alle E/A seriell an einem Bus. Wo der Feldbus aktiv ist, wird Feldebene genannt. Der Aufbau des Feldbusses kann wie folgt vorgestellt werden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_095610157.png}
\end{figure}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition Feldbus]
\textnormal{Ein Feldbus verbindet in einer Anlage Feldgeräte wie Sensoren und Aktoren zwecks Kommunikation mit einem Steuerungsgerät (SPS).}
\end{tcolorbox}

\textnormal{Durch den Feldbus entstehen einige wesentliche Vor- und Nachteile:}
\begin{itemize}[label=$+$]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item geringer Verkabelungsaufwand
    \item Erweiterungen oder Änderungen sind einfach
\end{itemize}
\begin{itemize}[label=$-$]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item Komplexität
    \item Preis
    \item Aufwendige Messgeräte (Analyzer)
    \item Längere Reaktionszeit
\end{itemize}

\subsection{Spezifische Feldbusse}
\textnormal{Im Gebäude sind die gängigen Feldbusse:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item LON
    \item EIB
    \item KNX
\end{itemize}

\textnormal{Innerhalb der Maschine werden andere Feldbusse verwendet:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item CAN/CANOpen
    \item Profibus, Profinet
    \item EtherCAT
    \item Ethernet/IP
\end{itemize}
\newcolumn

\chapter{Programmierung}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition SPS-Programmierung]
\textnormal{Die EN 61131-3 ist die einzige weltweit gültige Norm für Programmiersprachen von SPS-Steuerungen. Sie definiert die folgenden fünf Sprachen:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item AWL - Anweisungsliste (Assemler)
    \item KOP - Kontaktplan
    \item FBS - Funktionsbausteinsprache
    \item ST - Struktureierter Text
    \item AS - Ablaufsprache
\end{itemize}
\end{tcolorbox}
\textnormal{Die einzige (relevante) Programmiersprache hinsichtlich des IAUT Unterrichts ist ST. Die anderen werden für einfache logische Verknüpfungen gebraucht, oder für z.B. I/O-Zuweisungen. ST wird in Europa oft für die Programmierung von SPS gewählt.}

\section{EN 61499}
\textnormal{Diese Norm stellt eine objektorientierte Erweiterung der EN61131 dar.}

\chapter{Digitale Regelung}

\chapter{FSM - Finite State Machine}

\chapter{ST-Language}
\textnormal{Dieses Kapitel fasst den Aufbau und Syntax der SPS-Programmiersprache ST zusammen.}

\section{Grundaufbau}
\textnormal{Der Aufbau eines Programmes/Funktionsblockes oder Funktion ist immer in zwei Bereiche aufgeteilt: Deklaration und Implementation. Im Deklarationsteil werden alle Inputs, Outputs deklariert und ggf. initialisiert. In der Implementation wird der eigentliche Code geschrieben. Wichtig: die Implementation wird in jedem Clock Zyklus wiederholt.}

\stlisting

\begin{lstlisting}[]
// Deklarationsteil
VAR_INPUT
    // input-variablen
    iVarIn AT %I* : INT;
END_VAR
VAR_OUTPUT
    // output-variablen
    iVarOut AT %Q* : INT;
END_VAR
VAR_IN_OUT
    // in/out-variablen
END_VAR
VAR
    // lokale variablen
    tmp : INT;
END_VAR

// Implementationsteil
IF iVarIn > 10 THEN
    tmp := 0;
ELSE
    tmp := iVarIn;
END_IF
\end{lstlisting}

\section{Variablentypen}

\subsection{System Datentypen}
\textnormal{Die gängigen Datentypen sind auch in ST vorhanden. Die Tabelle fasst die Datentypen zusammen:}

\begin{table}[H]
    \centering
    \tabularcount
    \begin{tabular}{| p{0.7cm} | p{1.6cm} | p{1.9cm}| p{0.6cm} | p{2cm}|}
        \hline
        Typ & Min & Max & Bits & Bemerkung\\
        \hline
        \mintinline{C}{bool}&0&1&8&Nur 1 / 0 / \mintinline{C}{TRUE} / \mintinline{C}{FALSE} sind gültig!\\\hline
        \mintinline{C}{BYTE}&0&255&8&\\\hline
        \mintinline{C}{WORD}&0&65535&16&\\\hline
        \mintinline{C}{DWORD}&0&4294967295&32&\\\hline
        \mintinline{C}{SINT}&-128&127&8&\\\hline
        \mintinline{C}{USINT}&0&255&8&\\\hline
        \mintinline{C}{INT}&-32768&32767&16&\\\hline
        \mintinline{C}{UINT}&0&65535&16&\\\hline
        \mintinline{C}{DINT}&$-$2147483648&2147483647&32&\\\hline
        \mintinline{C}{UDINT}&0&4294967295&32&\\\hline
        \mintinline{C}{REAL}&$-3.4\cdot10^{38}$&$-3.4\cdot10^{38}$&64&\\\hline
        \mintinline{C}{LREAL}&$-1.8\text{E}+308$&$1.8\text{E}+308$&64&\\\hline
        \mintinline{C}{STRING}&$-$&$-$&$n+1$&fügt Nullterminierung an.\\\hline
        \mintinline{C}{TIME}&\mintinline{C}{T#0ms}&\mintinline{C}{T#71582m}&32&\\
        &&\mintinline{C}|47s295ms|&&\\\hline
        \mintinline{C}{TOD}&\mintinline{C}{TOD#00:00}&\mintinline{C}{TOD#1193:02:}&32&\\
        &&\mintinline{C}{47.295}&&\\\hline
        \mintinline{C}{DATE}&\mintinline{C}{D#1970-01-01}&\mintinline{C}{D#2106-02-06}&32&\\\hline
        \mintinline{C}{DT}&\mintinline{C}{DT#1970-0-0}&\mintinline{C}{DT#2106-02-06-}&32&\\
        &\mintinline{C}{-00:00}&\mintinline{C}{06:28:15}&&\\\hline
    \end{tabular}
\end{table}

\subsection{DUT - Data Unit Type}
\textnormal{Über DUT können benutzerdefinierte Datentypen angelegt werden. Die relevanten sind \mintinline{ST}{STRUCT} und \mintinline{ST}{ENUM}. Durch diese Typen kann ein Programm bedeutend lesbarer gestaltet werden.}

\subsection{Programm}
\textnormal{Hallo das ist das erste Mal wo ich von Linux aus das hier mache. So far so good, es geht wirklich gut.}

\subsection{Funktionsblock}

\subsection{Funktion}

\section{Variablen-Scope}

\subsection{Globale Variablen}
\textnormal{In einer globalen Variablenliste \mintinline{ST}{GVL} werden global verwendete Variablen deklariert. Sinnvoll ist dies zum Beispiel für: SPS Zykluszeit, Ein-/Ausgänge oder sonstige Konstanten, welche überall im Code wieder verwendet und gegebenenfalls ändern.}

\section{Conditional Statements}

\subsection{If/Else}
\begin{lstlisting}[]
IF <cond1> THEN
    ...
ELSIF <cond2> THEN
    ...
ELSE
    ...
END_IF
\end{lstlisting}

\subsection{Switch-Case}
\begin{lstlisting}[]
CASE iVar OF
    1:
        // do something for 1
    2..5:
        // do something for range 2 - 5
ELSE
    // do this as default-assignment
END_CASE;
\end{lstlisting}

\textnormal{Die Switch-Bedingung kann auch für Enum-Typen gebraucht werden:}
\begin{lstlisting}[]
CASE eState OF
    Init:
        // handle init state
    Running:
        // handle running state
    Error:
        // handle error state
ELSE
    // it is beneficial to always have a default statement
END_CASE;
\end{lstlisting}

\section{Schleifen}
\textnormal{Wie in C gibt es in TwinCat Schleifen. Dabei ist es von zentraler Bedeutung, dass diese Schleife nicht Endlos ist und eine Abbruchbedingung enthält. Ansonsten kann es vorkommen, dass auf die SPS nicht mehr zugegriffen werden kann. Die verschiedenen Schleifen werden hier aufgeführt.}

\subsection{WHILE}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=WHILE-Schleife]
\textnormal{Sofern die Bedingung beim ersten Erreichen nicht zutrifft, wird der Inhalt der Schleife nicht ausgeführt.}
\end{tcolorbox}

\begin{lstlisting}[]
WHILE iCounter <> 0 DO
    iVar1 := iVar2;
    iCounter := iCounter - 1;
END_WHILE;
\end{lstlisting}

\subsection{REPEAT}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=REPEAT-Schleife]
\textnormal{Diese Schleife wird mindestens einmal durchgeführt.}
\end{tcolorbox}

\begin{lstlisting}[]
REPEAT
    iVar1 := iVar2;
    iCounter := iCounter - 1;
UNTIL
    iCounter = 0;
END_REPEAT;
\end{lstlisting}

\subsection{FOR}
\begin{lstlisting}
FOR iCounter = 1 TO 5 BY 1 DO
    iVar1 := iVar2;
END_FOR;
\end{lstlisting}

\subsection{Schleifen Modifikatoren}
\textnormal{Mit diesen Modifikatoren kann wie in C beeinflusst werden, wie das Verhalten in der Schleife ist.}
\begin{lstlisting}
EXIT;       // Ausbruch aus aktuellem Loop 
CONTINUE;   // Direkter Sprung zu Loop Anfang
\end{lstlisting}



\chapter{TwinCat}
\textnormal{TwinCat ist die Entwicklungsumgebung von Beckoff für deren SPS Systeme. TwinCat liefert diverse Funktionen vorgefertigt für den Benutzer. In diesem Kapitel werden die relevantesten aufegelistet.}

\section{Bitshifting}
\textnormal{Mit Bitshifting Operationen können sämtliche Bits innerhalb einer Variable nach links oder rechts geshiftet werden. Die Bits am Rand werden verworfen und neu entstandene Lücken mit 0 aufgefüllt.}

\begin{lstlisting}
res := SHL(bByte, 2);   // Shift Left
res := SHR(bByte, 2);   // Shift Right
\end{lstlisting}

\textnormal{Mit Bitrotate Befehlen können herausgeschobene Bits rotiert werden (herausgeschobene Bits werden am anderen Ende wieder hineingeschoben).}

\begin{lstlisting}
res := ROL(bByte,2);    // Circular Shift Left
res := ROL(bByte,3);    // Circular Shift Right
\end{lstlisting}

\textnormal{Die Shift-Operationen können mit allen gängigen Datentypen verwendet werden.}

\section{Limit}



\chapter{Beispiel Code}