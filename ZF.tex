\chapter{Automatisierung}

\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition Automatisierung]
\textnormal{Unter Automatisierung (DIN19222) versteht man das gezielte Ausrüsten einer Einrichtung, so dass sie ganz oder teilweise ohne Mitwirkung des Menschen geschieht und arbeiten kann.}
\end{tcolorbox}

\textnormal{Die Automatisierungspyramide ist der Versuch die gesamte Automatisierungskette auf ein Bild abzubilden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.8\columnwidth]{img/Bild_2025-09-23_094245630.png}
\end{figure}
\textnormal{Die Darstellung ist wie folgt zu interpretieren: Je weiter unten, desto schneller müssen die Komponenten reagieren und je weiter oben, ist die Datenmenge grösser. Die Absicht der Automatisierung ist, dass die automatisierte Anlage bis ins ERP der Firma eingepflegt wird. So muss z.B. keine spezielle Benutzeroberfläche geladen werden um ein neuer Prozess auf der Anlage zu starten.}

\section{Steuerung - Überblick}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.4\columnwidth]{img/Bild_2025-09-23_093009913.png}
\end{figure}
\textnormal{Die Bedienung ist wo das GUI (Graphical User Interface) dargestellt wird. Hier werden vom Benutzer Eingaben getätigt, wie z.B. Job oder Rezeptwahl.}\\
\textnormal{Der Controller innerhalb der Steuerung/Anlage ist die CPU/SPS. Eine Automatisierung ist häufig eine (PID-)Regelungsaufgabe. Die SPS ist mit Aktoren und Sensoren verbunden:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item Sensoren liefern Informationen
    \item Aktoren lösen Aktion aus
\end{itemize}
\textnormal{Die Schnittstellen der Sensoren/Aktoren ist entweder eine Spannung oder einen Strom. Die Spannung ist jedoch eher weniger gängig im Moment, da die Spannung anfälliger auf Störeinflüsse ist als ein Strom. Die gängigsten Schnittstellen sind. Ein weiterer Vorteil der Stromschnittstelle ist, dass auch ein Kabelbruch detektiert werden kann, da der Strom nie 0 wird:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item $0V-10V$
    \item $4mA - 20mA$
\end{itemize}
\newcolumn

\subsection{Klemmen}
\textnormal{Die Klemmen stellen die Ein- und Ausgänge einer SPS dar und können auf der Feldebene der SPS über ein Bussystem erweitert werden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_093955196.png}
\end{figure}
\textnormal{Klemmen können über RS485 abgesetzt werden und an einem anderen Ort als direkt bei der SPS eingesetzt werden.}

\section{Allgemeine Aufgaben}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_094648272.png}
\end{figure}

\section{Allgemeine Anforderungen}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_094725052.png}
\end{figure}
\newcolumn

\chapter{SPS}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.3\columnwidth]{img/Bild_2025-09-23_095018637.png}
\end{figure}
\textnormal{Eine SPS ist eine 'Speicherprogrammierbare Steuerung'. Auf Englisch wird sie PLC (Programmable Logic Controller) genannt. Sehr wichtig: die SPS arbeitet konventionell möglichst auf if/else Statements und verarbeitet sämtlicher Code in jedem Zyklus einmal. Das Arbeitsprinzip ist:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bild_2025-09-23_095127951.png}
\end{figure}

\section{Feldbus}
\textnormal{Der Feldbus ist die Kommunikationsschnittstelle der SPS zu den Klemmen und entsprechend Ein- und Ausgängen. Es hängen alle E/A seriell an einem Bus. Wo der Feldbus aktiv ist, wird Feldebene genannt. Der Aufbau des Feldbusses kann wie folgt vorgestellt werden:}
\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bild_2025-09-23_095610157.png}
\end{figure}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition Feldbus]
\textnormal{Ein Feldbus verbindet in einer Anlage Feldgeräte wie Sensoren und Aktoren zwecks Kommunikation mit einem Steuerungsgerät (SPS).}
\end{tcolorbox}

\textnormal{Durch den Feldbus entstehen einige wesentliche Vor- und Nachteile:}
\begin{itemize}[label=$+$]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item geringer Verkabelungsaufwand
    \item Erweiterungen oder Änderungen sind einfach
\end{itemize}
\begin{itemize}[label=$-$]
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item Komplexität
    \item Preis
    \item Aufwendige Messgeräte (Analyzer)
    \item Längere Reaktionszeit
\end{itemize}

\subsection{Spezifische Feldbusse}
\textnormal{Im Gebäude sind die gängigen Feldbusse:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item LON
    \item EIB
    \item KNX
\end{itemize}

\textnormal{Innerhalb der Maschine werden andere Feldbusse verwendet:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item CAN/CANOpen
    \item Profibus, Profinet
    \item EtherCAT
    \item Ethernet/IP
\end{itemize}
\newcolumn

\chapter{Programmierung}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Definition SPS-Programmierung]
\textnormal{Die EN 61131-3 ist die einzige weltweit gültige Norm für Programmiersprachen von SPS-Steuerungen. Sie definiert die folgenden fünf Sprachen:}
\begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item AWL - Anweisungsliste (Assemler)
    \item KOP - Kontaktplan
    \item FBS - Funktionsbausteinsprache
    \item ST - Struktureierter Text
    \item AS - Ablaufsprache
\end{itemize}
\end{tcolorbox}
\textnormal{Die einzige (relevante) Programmiersprache hinsichtlich des IAUT Unterrichts ist ST. Die anderen werden für einfache logische Verknüpfungen gebraucht, oder für z.B. I/O-Zuweisungen. ST wird in Europa oft für die Programmierung von SPS gewählt.}

\section{EN 61499}
\textnormal{Diese Norm stellt eine objektorientierte Erweiterung der EN61131 dar.}


\textnormal{Dieses Kapitel fasst den Aufbau und Syntax der SPS-Programmiersprache ST zusammen.}

\section{Grundaufbau}
\textnormal{Der Aufbau eines Programmes/Funktionsblockes oder Funktion ist immer in zwei Bereiche aufgeteilt: Deklaration und Implementation. Im Deklarationsteil werden alle Inputs, Outputs deklariert und ggf. initialisiert. In der Implementation wird der eigentliche Code geschrieben. Wichtig: die Implementation wird in jedem Clock Zyklus wiederholt.}

\stlisting

\begin{lstlisting}[]
// Deklarationsteil
VAR_INPUT
    // input-variablen
    iVarIn AT %I* : INT;
END_VAR
VAR_OUTPUT
    // output-variablen
    iVarOut AT %Q* : INT;
END_VAR
VAR_IN_OUT
    // in/out-variablen
END_VAR
VAR
    // lokale variablen
    tmp : INT;
END_VAR

// Implementationsteil
IF iVarIn > 10 THEN
    tmp := 0;
ELSE
    tmp := iVarIn;
END_IF
\end{lstlisting}
\newcolumn

\subsection{Programm}
\textnormal{Programme können als Funktionen aufgerufen werden und besitzen keinen Rückgabewert.}

\begin{lstlisting}
PROGRAM ProgramName
VAR
    bTrig : BOOL;
    iVal : INT;
END_VAR

IF(bTrig = TRUE) THEN
    iVal := 15;
END_IF
\end{lstlisting}

\subsection{Funktionsblock}
\textnormal{Ein Funktionsblock ist Zustandsbehaftet: Interne Variablen behalten ihren Wert über die SPS-Zyklen weg. Jede Instanz besitzt einen eigenen Speicher. Jedoch müssen die Speicher instanziert werden.}

\begin{lstlisting}
FUNCTION_BLOCK Count
VAR_INPUT
    bTrig : BOOL;
END_VAR
VAR
    iCount : INT;
END_VAR

IF bTrig = TRUE THEN
    iCount := iCount + 1;
END_IF
\end{lstlisting}

\subsection{Funktion}
\textnormal{Eine Funktion kann ohne Instanzierung verwendet werden. Eine Funktion besitzt keine statische Werte, dafür einen Rückgabewert, welcher auf den Funktionsnamen zugewiesen wird.}

\begin{lstlisting}
FUNCTION fFunc : INT // Ruckgabewert
VAR_INPUT
    iTime : INT;
    iT : INT;
END_VAR

iTmp := iTime;
fFunc := iTime / iT;
\end{lstlisting}
\newcolumn

\section{Variablentypen}

\subsection{System Datentypen}
\textnormal{Die gängigen Datentypen sind auch in ST vorhanden. Die Tabelle fasst die Datentypen zusammen:}

\begin{table}[H]
    \centering
    \tabularcount
    \begin{tabular}{| p{0.7cm} | p{1.6cm} | p{1.9cm}| p{0.6cm} | p{2cm}|}
        \hline
        Typ & Min & Max & Bits & Bemerkung\\
        \hline
        \mintinline{C}{bool}&0&1&8&Nur 1 / 0 / \mintinline{C}{TRUE} / \mintinline{C}{FALSE} sind gültig!\\\hline
        \mintinline{C}{BYTE}&0&255&8&\\\hline
        \mintinline{C}{WORD}&0&65535&16&\\\hline
        \mintinline{C}{DWORD}&0&4294967295&32&\\\hline
        \mintinline{C}{SINT}&-128&127&8&\\\hline
        \mintinline{C}{USINT}&0&255&8&\\\hline
        \mintinline{C}{INT}&-32768&32767&16&\\\hline
        \mintinline{C}{UINT}&0&65535&16&\\\hline
        \mintinline{C}{DINT}&$-$2147483648&2147483647&32&\\\hline
        \mintinline{C}{UDINT}&0&4294967295&32&\\\hline
        \mintinline{C}{REAL}&$-3.4\cdot10^{38}$&$-3.4\cdot10^{38}$&64&\\\hline
        \mintinline{C}{LREAL}&$-1.8\text{E}+308$&$1.8\text{E}+308$&64&\\\hline
        \mintinline{C}{STRING}&$-$&$-$&$n+1$&fügt Nullterminierung an.\\\hline
        \mintinline{C}{TIME}&\mintinline{C}{T#0ms}&\mintinline{C}{T#71582m}&32&\\
        &&\mintinline{C}|47s295ms|&&\\\hline
        \mintinline{C}{TOD}&\mintinline{C}{TOD#00:00}&\mintinline{C}{TOD#1193:02:}&32&\\
        &&\mintinline{C}{47.295}&&\\\hline
        \mintinline{C}{DATE}&\mintinline{C}{D#1970-01-01}&\mintinline{C}{D#2106-02-06}&32&\\\hline
        \mintinline{C}{DT}&\mintinline{C}{DT#1970-0-0}&\mintinline{C}{DT#2106-02-06-}&32&\\
        &\mintinline{C}{-00:00}&\mintinline{C}{06:28:15}&&\\\hline
    \end{tabular}
\end{table}

\subsection{Array}
\begin{lstlisting}
VAR
    aValues : ARRAY[0..99] OF INT;
END_VAR
\end{lstlisting}

\subsection{DUT - Data Unit Type}
\textnormal{Über DUT können benutzerdefinierte Datentypen angelegt werden. Die relevanten sind \mintinline{ST}{STRUCT} und \mintinline{ST}{ENUM}. Durch diese Typen kann ein Programm bedeutend lesbarer gestaltet werden. Für die Erstellung eines DUTs wird ein neues File in der DUT Ordnerstruktur erstellt. Die Definition geht wie folgt:}

\begin{lstlisting}
// Struct
TYPE stDataType:
STRUCT
    iVar1 : INT;
    iPointX : INT;
    iPointY : INT;
END_STRUCT
END_TYPE
\end{lstlisting}

\begin{lstlisting}
// Enumeration
TYPE eSystemState:
(
    None, // = 0 - default
    init, // = 1
    run
) := init; // default state
END_TYPE
\end{lstlisting}
\newcolumn

\subsection{Globale Variablen Liste (GVL)}
\textnormal{Die GVL deklariert Variablen, welche in jedem Programm, Funktionsblock und Funktion aufrufbar. Vielfach machts Sinn die In-/Outputs, welche mit der Hardware kommunizieren in einer GVL zu deklarieren.}

\subsection{Type Casting}
\textnormal{Variablentypen können mit Hilfe von Casting Funktionen umgewandelt werden. Fast alle Typen können gewandelt werden:}

\begin{lstlisting}
rRealVal := INT_TO_REAL(iVal);
\end{lstlisting}

\textnormal{Casting ist die zielführende Methode, um keine Fehler im Implementieren des Programms zu generieren. TwinCat hat implizite Casts nicht so gerne.}

\section{Conditional Statements}

\subsection{If/Else}
\begin{lstlisting}[]
IF <cond1> THEN
    ...
ELSIF <cond2> THEN
    ...
ELSE
    ...
END_IF
\end{lstlisting}

\subsection{Switch-Case}
\begin{lstlisting}[]
CASE iVar OF
    1:
        // do something for 1
    2..5:
        // do something for range 2 - 5
ELSE
    // do this as default-assignment
END_CASE
\end{lstlisting}

\textnormal{Die Switch-Bedingung kann auch für Enum-Typen gebraucht werden:}
\begin{lstlisting}[]
CASE eState OF
    Init:
        // handle init state
    Running:
        // handle running state
    Error:
        // handle error state
ELSE
    // it is beneficial to always have a default statement
END_CASE
\end{lstlisting}

\section{Schleifen}
\textnormal{Wie in C gibt es in TwinCat Schleifen. Dabei ist es von zentraler Bedeutung, dass diese Schleife nicht Endlos ist und eine Abbruchbedingung enthält. Ansonsten kann es vorkommen, dass auf die SPS nicht mehr zugegriffen werden kann. Die verschiedenen Schleifen werden hier aufgeführt.}

\subsection{WHILE}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=WHILE-Schleife]
\textnormal{Sofern die Bedingung beim ersten Erreichen nicht zutrifft, wird der Inhalt der Schleife nicht ausgeführt.}
\end{tcolorbox}

\begin{lstlisting}[]
WHILE iCounter <> 0 DO
    iVar1 := iVar2;
    iCounter := iCounter - 1;
END_WHILE
\end{lstlisting}
\newcolumn

\subsection{REPEAT}
\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=REPEAT-Schleife]
\textnormal{Diese Schleife wird mindestens einmal durchgeführt.}
\end{tcolorbox}

\begin{lstlisting}[]
REPEAT
    iVar1 := iVar2;
    iCounter := iCounter - 1;
UNTIL
    iCounter = 0;
END_REPEAT
\end{lstlisting}

\subsection{FOR}
\begin{lstlisting}
FOR iCounter = 1 TO 5 BY 1 DO
    iVar1 := iVar2;
END_FOR
\end{lstlisting}

\subsection{Schleifen Modifikatoren}
\textnormal{Mit diesen Modifikatoren kann wie in C beeinflusst werden, wie das Verhalten in der Schleife ist.}
\begin{lstlisting}
EXIT        // Ausbruch aus aktuellem Loop 
CONTINUE    // Direkter Sprung zu Loop Anfang
\end{lstlisting}



\chapter{TwinCat}
\textnormal{TwinCat ist die Entwicklungsumgebung von Beckoff für deren SPS Systeme. TwinCat liefert diverse Funktionen vorgefertigt für den Benutzer. In diesem Kapitel werden die relevantesten aufegelistet.}

\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Semicolons]
\textnormal{TwinCat ist sehr tolerant was Semicolons nach \mintinline{C}{END_*} Anweisungen betrifft. Gemäss Standard wird jede Anweisung mit \mintinline{C}|;| abgeschlossen. TwinCat toleriert das nicht Setzen dieser Semicolons.}
\end{tcolorbox}

\section{Bitshifting}
\textnormal{Mit Bitshifting Operationen können sämtliche Bits innerhalb einer Variable nach links oder rechts geshiftet werden. Die Bits am Rand werden verworfen und neu entstandene Lücken mit 0 aufgefüllt.}

\begin{lstlisting}
res := SHL(bByte, 2);   // Shift Left
res := SHR(bByte, 2);   // Shift Right
\end{lstlisting}

\textnormal{Mit Bitrotate Befehlen können herausgeschobene Bits rotiert werden (herausgeschobene Bits werden am anderen Ende wieder hineingeschoben).}

\begin{lstlisting}
res := ROL(bByte,2);    // Circular Shift Left
res := ROL(bByte,3);    // Circular Shift Right
\end{lstlisting}

\textnormal{Die Shift-Operationen können mit allen gängigen Datentypen verwendet werden.}

\section{Limit}
\textnormal{Die Limit-Funktion limitiert die Eingangsvariable innerhalb von einer Minimal- und Maximalwert. Die Funktion kann wie folgt verwendet werden:}

\begin{lstlisting}
rUsat := LIMIT(umin, rU, umax);
// rU wird von umin und umax limitiert
\end{lstlisting}
\newcolumn

\section{Timer}
\textnormal{Verschiedene Timer Module können direkt aus TwinCat instanziiert werden. Diese haben jeweils verschiedene Verhaltensmuster und sind für andere Anwendungen nützlich.}

\subsection{Timer Off-Delay (TOF)}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 15-02-56.png}
\end{figure}

\begin{lstlisting}
VAR
    fbTOF : TOF;
END_VAR

fbTOF(IN := bTrig, PT := T#500ms);
bOut := fbTOF.Q;
\end{lstlisting}

\subsection{Timer On-Delay (TON)}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 15-10-29.png}
\end{figure}

\begin{lstlisting}
VAR
    fbTON : TON;
END_VAR    

fbTON(IN := bTrig, PT := T#500ms);
bOut := fbTON.Q;
\end{lstlisting}

\subsection{Timer Pulse Generator (TP)}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 15-14-37.png}
\end{figure}

\begin{lstlisting}
VAR
    fbTP : TP;
END_VAR 

fbTP(IN := bTrig, PT := T#500ms);
bOut := fbTP.Q;
\end{lstlisting}
\newcolumn

\chapter{Digitale Regelung}
\textnormal{Für Automationsanwendungen werden sehr häufig PID-Regler verwendet. Für eine digitale Regelung muss der Prozess und der Regler diskretisiert werden. Verschiedene Diskretisierungsmethoden existieren.}

\section{Laplace Diskretisierung}
\textnormal{Um ein System in Laplace Bereich zu diskretisieren (in den z-Bereich) zu transformieren existieren verschiedene Methoden. Diese sind hier aufgeführt.}

\subsection{Rückwärts-Rechteckregel}
\begin{equation*}
    s = \frac{z-1}{T_Sz} = \frac{1-z^{-1}}{T_S}
\end{equation*}
\textnormal{Wobei $T_S$ die Zykluszeit der SPS ist. Diese ist standardmässig 10 ms. Gängigste Art zu diskretisieren}

\subsection{Vorwärtsrechteck-Regel}
\begin{equation*}
    s = \frac{z-1}{T_S}
\end{equation*}
\textnormal{Für Regelung eine ungeeignete Diskretisierungsmethode.}

\subsection{Trapezoidal-Regel (Tustin Approximation)}
\begin{equation*}
    s = \frac{2}{T}\frac{z-1}{z+1}
\end{equation*}

\section{PT1-Prozess}

\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{plt/PT1-Freq.pdf}
\end{figure}

\textnormal{PT1 Glieder besitzen eine Phasenverschiebung von 90$^\circ$ bzw. $\frac{\pi}{2}$. Die Grenzfrequenz liegt bei $\omega_0 = 2\pi\tau$.}

\begin{equation*}
    G(s) = \frac{1}{1+\tau s} \rightarrow y[k] = a_1 x[k] - a_2 y[k-1]
\end{equation*}
\begin{equation*}
    \text{Mit: }a_1 = \frac{T_S}{T_S+\tau} \quad a_2 = \frac{\tau}{T_S + \tau}
\end{equation*}
\newcolumn

\section{PT2-Prozess}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{plt/PT2-Freq.pdf}
\end{figure}

\textnormal{Mit zunehmender Dämpfung $d$ sinkt die Resonanz bei der Grenzfrequenz $\omega_0$. Die Phasenverschiebung ist $180^\circ$ respektive $\pi$.}
\begin{equation*}
    G(s)=\frac{\omega_0^2}{s^2+2d\omega_0s+\omega_0^2}
\end{equation*}

\textnormal{Diskretisiert:}
\begin{equation*}
    y[k] = \frac{a_3}{a_1}x[k] - \frac{a_2}{a_1}y[k-1] - \frac{1}{a_1} y[k-2]
\end{equation*}
\begin{equation*}
    \text{Mit: }a_1 = 1+2d\omega_0T_s + \omega_0^2 \quad a_2 = -2-2d\omega_0T_s \quad a_3 = T_s^2\omega_0^2
\end{equation*}

\section{Diskreter PID-Regler}

\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 17-10-47.png}
\end{figure}

\textnormal{Der PID-Regler muss auch diskretisiert werden. Der zeitkontinuierliche PID-Regler hat die Form:}
\begin{equation*}
    C(s) = \frac{U(s)}{E(s)} = k_P \left( 1 + \frac{1}{T_i s} + \frac{T_ds}{\frac{T_d}{N}s+1} \right)
\end{equation*}

\begin{table}[H]
    \centering
    \begin{tabular}{l l}
        \textbf{Legende:}\\
        $k_P$:&Reglerverstärkung\\
        $T_i$:&Nachstellzeit [s]\\
        $T_d$:&Vorhaltzeit [s]\\
        $N$:&$\frac{T_d}{N}$ ist die Zeitkonstante des Filters
    \end{tabular}
\end{table}

\subsection{P-Anteil}
\textnormal{Der diskretisierte P-Anteil ist somit:}
\begin{equation*}
    u_P[k] = k_P \cdot e[k]
\end{equation*}

\subsection{I-Anteil}
\textnormal{Der diskretisierte I-Anteil des Reglers ist:}
\begin{equation*}
    u_I = u_I[k-1] + \frac{k_PT_s}{T_i} e[k]
\end{equation*}

\subsection{D-Anteil}
\textnormal{Der diskretisierte D-Anteil des Reglers ist:}
\begin{equation*}
    u_D = \frac{k_P\cdot T_d}{T_s}(e[k]-e[k-1])
\end{equation*}

\begin{tcolorbox}[colback=VeryLightOrange,colframe=DarkOrange,title=Kompletter diskreter PID-Regler]
\textnormal{Der diskretisierte PID-Regler ist damit zusammengesetzt:}
\begin{equation*}
    u = u_P + u_I + u_D
\end{equation*}
\textnormal{Die vorhergehenden Fehler und Stellgrössen müssen immer mitgeführt werden.}
\end{tcolorbox}

\section{Stellgrössensättigung}
\textnormal{Fast alle Stellgrössen sind in ihrem Output limitiert. Damit die Hardware keinen Schaden nehmen kann, muss die Stellgrösse in der Software gesättigt werden. Die Sättigungsfunktion funktioniert anhand eines einfachen mathematischen Prinzips:}
\begin{equation*}
    u_{sat}[k] = 
    \begin{cases}
        u_{max},& \text{wenn }u[k] > u_{max}\\
        u_{min},& \text{wenn }u[k] < u_{min}\\
        u[k], & \text{sonst}
    \end{cases}
\end{equation*}

\textnormal{Die Stellgrössensättigung generiert ein neues Problem: der I-Anteil kann sich in die Unendlichkeit aufintegrieren. Um das Problem einzugrenzen, wird ein Antireset-Windup (ARW) implementiert. Das Sättigungsverfahren wird in ST wie folgt gelöst:}

\begin{lstlisting}
usat := LIMIT(umin, u, umax);
\end{lstlisting}

\subsection{Antireset-Windup (ARW)}

\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 17-15-16.png}
\end{figure}

\textnormal{Wird ein ARW implementiert, integriert sich der I-Anteil nicht mehr über das Limit heraus. Der Regler ist damit viel reaktiver. Der I-Anteil mit ARW ist somit:}
\begin{equation*}
    u_I[k] = u_I[k-1]+\frac{k_PT_s}{T_i}e[k] + \frac{T_s}{T_r}(u_{sat}[k]-u[k])
\end{equation*}
\textnormal{Wobei $u[k]$ die gesamte PID-Stellgrösse ohne Sättigung ist.}
\newcolumn

\chapter{FSM - Finite State Machine}
\textnormal{Finite State Machines oder FSM sind Zustandsmaschinen, welche je nach Zustand Ein- und Ausgänge anders behandeln. Wichtig dabei sind die Übergangsbedinungen, zu welchen der Zustand wechselt. Dargestellt werden sie in Zustandsdiagrammen. Ein einfaches Diagramm:}

\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-22 17-57-55.png}
\end{figure}

\textnormal{In ST ist es üblich, dass jeweils ein Enumerationstyp generiert wird, welcher die Zustände im code lesbarer macht:}

\begin{lstlisting}
TYPE eSystemState:
(
    none,
    init,
    run,
    error
)
END_TYPE
\end{lstlisting}

\textnormal{Im Programm geht das Ganze dann wie folgt von statten:}

\begin{lstlisting}
PROGRAM
VAR
    state : eSystemState;
    iTemp : REAL;
END_VAR

CASE state OF
    init:
        // handle init
        ....
        // next state
        IF iTemp >= 20 THEN
            state := run;
        END_IF
    run:
        // handle run
        ....
        // next state
        IF iTemp > 100 THEN
            // overtemperature protection
            state := error;
        END_IF
    error:
        // handle error
        ....
        IF bReset = TRUE THEN
            state := init;
        END_IF
ELSE
    state := init;
END_CASE
\end{lstlisting}

\newcolumn

\chapter{Beispiel Code}
\textnormal{Ein paar Beispiel Codes können hier entnommen werden.}

\section{Flankendetektor}
\textnormal{Damit ein Button nur einmal als gedrückt wahrgenommen wird, muss eine Flankendetektion implementiert werden. So kann auch darauf reagiert werden, wenn die Taste losgelassen wird. Für die Lesbarkeit, wird ein Enumerationstyp definiert.}

\subsection{Enumeration}
\begin{lstlisting}
// fuer die Button Flanken
TYPE sButtonState :
STRUCT
	bState : BOOL;
	bRisingEdge : BOOL;
	bFallingEdge : BOOL;
END_STRUCT
END_TYPE
\end{lstlisting}

\subsection{Funktionsblock}

\begin{figure}[H]
    \centering
    \includegraphics[width =  0.6\columnwidth]{img/Bildschirmfoto vom 2025-12-23 09-55-58.png}
\end{figure}

\begin{lstlisting}
FUNCTION_BLOCK EdgeDetector
VAR_INPUT
	bSignal : BOOL;
	iInterval : INT;
END_VAR
VAR_OUTPUT
	bFallingEdge : BOOL;
	bRisingEdge : BOOL;
END_VAR
VAR
	bPrevSignal : BOOL;
	state : eStateEdgeDetect;
	interval : INT;
END_VAR

IF bPrevSignal AND NOT bSignal THEN
	// falling edge detected
	bFallingEdge := 1;
	bRisingEdge := 0;
	state := eStateEdgeDetect.one_press;
ELSIF NOT bPrevSignal AND bSignal THEN
	// rising edge detected
	bFallingEdge := 0;
	bRisingEdge := 1;
	state := eStateEdgeDetect.one_press;
ELSE
	// edge is nor falling or rising
	bFallingEdge := 0;
	bRisingEdge := 0;
END_IF

// store signal for next cycle
bPrevSignal := bSignal;
\end{lstlisting}
\newcolumn

\section{PID-Regler}
\subsection{Parameter Struct}
\begin{lstlisting}
TYPE sPID_Params :
STRUCT
	Kp	    : REAL; // Proportional Faktor
	Ti	    : REAL; // Nachstellzeit
	Td	    : REAL; // Vorhaltzeit
	Tr	    : REAL; // ARW Zeitkonstante
	N	      : UINT; // Filterkonstante
	ARW     : BOOL; // ARW Enable/Disable
	umin    : REAL; // usat minimal
	umax    : REAL; // usat maximal
END_STRUCT
END_TYPE
\end{lstlisting}

\subsection{System Modus Enum}
\begin{lstlisting}
TYPE eSystem_Modus :
(
	System_Init := 0,
	System_Run := 1
);
END_TYPE
\end{lstlisting}

\subsection{Funktionsblock}
\begin{lstlisting}
FUNCTION_BLOCK fbPID
VAR_INPUT
	ref			  : REAL;
	y			    : REAL;
	Mode		  : eSystem_Modus;
	T			    : REAL;
	sPID_Par 	: sPID_Params;
END_VAR
VAR_IN_OUT
	
END_VAR
VAR_OUTPUT
	u    : REAL;
	usat : REAL;
END_VAR
VAR
	rParamI  : REAL;
	rParamD1 : REAL;
	rParamD2 : REAL;
	rE       : REAL;
	rEm      : REAL;
	rUp      : REAL;
	rUi      : REAL;
	rUim     : REAL;
	rUd      : REAL; 
	rUdm     : REAL;
	u_arw    : REAL;
END_VAR

rE := ref - y;		// momentary error
CASE Mode OF
	eSystem_Modus.System_Init:
		// Parameter for I-Part
		rParamI := sPID_Par.Kp*T / sPID_Par.Ti;
		// Parameter for D-Part
		rParamD1 := ( sPID_Par.N*sPID_Par.Kp*sPID_Par.Td ) / (sPID_Par.Td + sPID_Par.N*T);
		rParamD2 := ( sPID_Par.Td ) / (sPID_Par.Td + sPID_Par.N*T);
		u := 0;
	
	eSystem_Modus.System_Run:
		// P - Part
		rUp := sPID_Par.Kp * rE;
		// I - Part
		rUi := rUim + rParamI * rE;
		// D - Part
		rUd := rParamD1 * (rE - rEm) + rParamD2 * rUdm;
		u := rUp + rUi + rUd;
		// saturating u if out of bounds
		usat := LIMIT(u, sPID_Par.umin, sPID_Par.umax);
		IF sPID_Par.ARW THEN
    		rUi := rUi + (1.0 / sPID_Par.Tr) * (usat - u);
		END_IF
		rUim := rUi;
        rUdm := rUd;
        rEm := rE;
END_CASE
\end{lstlisting}

\section{PT1 Prozess}
\begin{lstlisting}
FUNCTION_BLOCK PT1
VAR_INPUT
	signal    : REAL;
	fg        : REAL;
END_VAR
VAR_OUTPUT
	out       : REAL;
END_VAR
VAR
	T         : REAL;
	tau       : REAL;
	prev_out  : REAL;
END_VAR

tau := 1/(2*pi*fg);
T:= 0.01;

out := (T/(T+tau))*signal + (tau/(T+tau))*prev_out;

prev_out := out;
\end{lstlisting}
\newcolumn

\section{PT2 Prozess}
\subsection{Parameter Struct}
\begin{lstlisting}
TYPE dPT1T2_Params :
STRUCT
	K  : REAL;
	T1 : REAL;
	T2 : REAL;
END_STRUCT
END_TYPE
\end{lstlisting}

\subsection{Funktionsblock}
\begin{lstlisting}
FUNCTION_BLOCK PT1T2_Prozess
VAR_INPUT
	u     : REAL;
	Modus : eSystem_Modus;
	Param : dPT1T2_Params;
	T     : REAL;
END_VAR
VAR_OUTPUT
	out : REAL;
END_VAR
VAR
	b0    : REAL;
	alph1 : REAL;
	alph2 : REAL;
	a1    : REAL;
	a2    : REAL;
	outm  : REAL;
	outmm : REAL;
END_VAR

CASE Modus OF
	eSystem_Modus.System_Init:
		// alphas
		alph1 := T + Param.T1;
		alph2 := T + Param.T2;
		// funct. parameters
		b0 := (Param.K * T * T) / (alph1*alph2);
		a1 := -( (Param.T1/alph1) + (Param.T2/alph2) );
		a2 := (Param.T1*Param.T2)/(alph1*alph2);
		
	eSystem_Modus.System_Run:
		out := -a1*outm - a2*outmm + b0 * u;
		outmm := outm;
		outm := out;
END_CASE
\end{lstlisting}

\newcolumn

\chapter{Matlab-Befehle}
\textnormal{Für die Auslegung und modellierung wurde in IAUT Matlab verwendet. Dabei wurden Tools wie der 'PID-Tuner' oder 'Siso-Tool' für die Auslegung der Regler eingesetzt. Grundsätzlich folgt der Reglerentwurf diesem Schema:}

\begin{enumerate}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \item Prozess messen
    \item Prozessmodellierung (Sprungantwort parametrisieren, etc.)
    \item Regler mit Tool auslegen
\end{enumerate}

\textnormal{Kennengelernte Matlab Befehle sind:}

\begin{lstlisting}
margin(C*H/(1+H*C))  // Phasen und Gain Reserve closed loop

num = [p0 0 0];
den = [p1 p2 p3];
H = tf(num,den,Ts); // Zeitdiskrete Uebertragungsfunktion

y = lsim(H, U, t/1000); // Sprungantwort simulieren

stepz(num,den,Ts) // Sprungantwort
freqz(num,den) // Frequenzgang
\end{lstlisting}

\section{Sprungantwort modellieren}
\textnormal{Um eine Sprungantwort zu modellieren, muss jeweils entschieden werden, wie der Sprung am besten simuliert werden kann. Der Sprung muss immer genullt werden (bei 0 starten) aber darf beim Aufnehmen nicht bei 0 starten. Entsprechend: Motor Bsp 500 rpm zu 1500 rmp. Dann -500 rechnen, um Sprung zu modellieren. Ein Modell eines Sprunges kann so aussehen:}

\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Prozessmodellierung.pdf}
\end{figure}

\section{Simulink}
\textnormal{Das Modell kann genau so nachgebaut werden, wie modelliert. Dann kann mittels diskreten PID-Regler den Regler ausgelegt werden.}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{img/Bildschirmfoto vom 2025-12-23 10-39-11.png}
\end{figure}

\newcolumn

\chapter{Hilfsblätter}
\section{Laplace Transformation}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{hilfsblatt/Laplace1.pdf}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{hilfsblatt/Laplace2.pdf}
\end{figure}
\newcolumn

\section{$z$-Transformation}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{hilfsblatt/zTrans1.pdf}
\end{figure}
\begin{figure}[H]
    \centering
    \includegraphics[width =  \columnwidth]{hilfsblatt/zTrans2.pdf}
\end{figure}